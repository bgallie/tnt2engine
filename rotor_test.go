// This is free and unencumbered software released into the public domain.
// See the UNLICENSE file for details.

package tnt2engine

import (
	"math/big"
	"reflect"
	"testing"
)

func TestNewRotor(t *testing.T) {
	type args struct {
		size  int
		start int
		step  int
		rotor []byte
	}
	tests := []struct {
		name string
		args args
		want *Rotor
	}{
		{
			name: "tnr",
			args: args{
				size:  1783,
				start: 863,
				step:  1033,
				rotor: []byte{
					184, 25, 190, 250, 35, 11, 111, 218, 111, 1, 44, 59, 137, 12, 184, 22,
					154, 226, 101, 88, 167, 109, 45, 92, 19, 164, 132, 233, 34, 133, 138, 222,
					59, 49, 123, 208, 179, 248, 61, 216, 55, 59, 235, 57, 67, 172, 233, 232,
					87, 236, 189, 170, 196, 124, 216, 109, 4, 106, 207, 150, 166, 164, 99, 57,
					131, 27, 1, 236, 168, 78, 122, 81, 165, 26, 32, 56, 129, 105, 35, 26,
					247, 208, 56, 235, 91, 183, 67, 150, 112, 103, 173, 197, 69, 13, 115, 14,
					129, 206, 74, 46, 119, 208, 95, 67, 119, 7, 191, 210, 128, 117, 140, 245,
					41, 168, 63, 203, 53, 241, 221, 28, 158, 40, 89, 76, 126, 58, 33, 40,
					78, 130, 93, 116, 206, 66, 4, 10, 109, 86, 150, 53, 200, 34, 26, 37,
					232, 185, 214, 47, 131, 18, 241, 210, 18, 81, 107, 161, 97, 65, 238, 250,
					81, 133, 54, 158, 54, 10, 254, 135, 110, 162, 175, 250, 117, 66, 232, 66,
					50, 102, 70, 76, 185, 249, 57, 59, 247, 195, 101, 8, 157, 235, 24, 94,
					204, 74, 100, 196, 93, 24, 179, 27, 118, 168, 29, 10, 38, 204, 210, 123,
					111, 247, 225, 171, 60, 166, 239, 124, 43, 180, 223, 240, 66, 2, 68, 220,
					12, 95, 253, 145, 133, 55, 237, 183, 0, 150, 157, 68, 6, 92, 11, 77,
					241, 50, 172, 211, 182, 22, 174, 9, 82, 194, 116, 145, 66, 69, 111, 0},
			},
			want: proFormaRotors[0],
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := new(Rotor).New(tt.args.size, tt.args.start, tt.args.step, tt.args.rotor); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("NewRotor() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestRotor_Update(t *testing.T) {
	tnt2Machine := new(Tnt2Engine)
	tnt2Machine.Init([]byte("SecretKey"), "")
	tnt2Machine.SetEngineType("E")
	tnt2Machine.SetIndex(BigZero)
	tnt2Machine.BuildCipherMachine()
	rnd := new(Rand).New(tnt2Machine)
	defer tnt2Machine.CloseCipherMachine()
	tests := []struct {
		name string
		want *Rotor
	}{
		{
			name: "tur1",
			want: new(Rotor).New(8123, 5335, 4199, []byte{
				176, 82, 92, 117, 203, 21, 130, 92, 140, 152, 112, 151, 71, 110, 223, 238,
				45, 8, 56, 63, 104, 198, 171, 28, 28, 13, 0, 102, 254, 255, 236, 177,
				109, 202, 44, 216, 154, 70, 4, 117, 191, 215, 24, 132, 43, 128, 238, 93,
				131, 186, 150, 187, 223, 24, 182, 126, 159, 179, 163, 164, 212, 132, 140, 201,
				173, 89, 64, 185, 165, 103, 163, 93, 222, 39, 212, 30, 80, 228, 220, 189,
				187, 192, 172, 31, 134, 216, 135, 105, 154, 38, 126, 0, 90, 24, 82, 158,
				179, 172, 25, 120, 171, 185, 237, 31, 22, 106, 218, 83, 182, 31, 53, 213,
				135, 196, 137, 158, 63, 150, 206, 136, 34, 35, 244, 70, 194, 235, 112, 71,
				205, 78, 78, 223, 133, 152, 185, 145, 133, 82, 2, 40, 120, 207, 195, 170,
				176, 61, 55, 153, 252, 200, 221, 135, 42, 122, 32, 51, 88, 86, 76, 24,
				136, 53, 95, 70, 81, 126, 67, 124, 35, 49, 219, 116, 176, 203, 97, 141,
				202, 161, 161, 167, 144, 60, 69, 14, 100, 204, 128, 235, 117, 84, 99, 1,
				80, 249, 226, 73, 205, 188, 65, 183, 124, 9, 214, 150, 237, 158, 51, 67,
				191, 65, 14, 212, 59, 238, 246, 189, 83, 80, 237, 164, 212, 164, 47, 234,
				162, 99, 146, 12, 239, 61, 182, 95, 16, 19, 58, 182, 159, 14, 190, 127,
				168, 162, 14, 158, 81, 140, 87, 182, 18, 25, 109, 168, 225, 15, 114, 144,
				12, 47, 94, 107, 156, 154, 45, 194, 22, 120, 75, 86, 229, 180, 253, 43,
				198, 253, 176, 182, 183, 11, 153, 35, 230, 8, 167, 222, 183, 139, 129, 215,
				33, 242, 33, 114, 231, 123, 143, 88, 238, 23, 237, 114, 192, 197, 52, 217,
				251, 223, 177, 130, 189, 165, 49, 72, 146, 133, 87, 175, 17, 52, 219, 234,
				10, 27, 11, 251, 38, 209, 214, 168, 163, 20, 225, 195, 63, 246, 145, 130,
				57, 183, 150, 248, 9, 130, 192, 157, 184, 142, 42, 114, 171, 158, 160, 247,
				24, 242, 131, 69, 187, 17, 68, 68, 37, 52, 75, 63, 199, 101, 138, 180,
				0, 158, 102, 15, 249, 219, 226, 3, 18, 229, 164, 29, 148, 42, 89, 177,
				84, 169, 1, 117, 114, 3, 56, 174, 42, 136, 27, 205, 0, 106, 100, 250,
				157, 175, 226, 218, 29, 46, 24, 20, 89, 112, 20, 255, 165, 202, 122, 194,
				29, 232, 125, 86, 72, 251, 85, 225, 175, 52, 198, 24, 2, 175, 127, 198,
				62, 253, 233, 192, 62, 70, 217, 80, 227, 19, 70, 45, 54, 167, 53, 154,
				168, 169, 75, 27, 13, 139, 78, 41, 154, 221, 47, 179, 119, 21, 82, 61,
				64, 55, 166, 40, 57, 70, 88, 165, 6, 165, 173, 89, 173, 66, 92, 74,
				69, 254, 59, 108, 180, 181, 63, 230, 169, 65, 201, 118, 210, 142, 60, 207,
				205, 148, 218, 11, 152, 16, 230, 99, 125, 138, 167, 59, 3, 150, 34, 33,
				231, 162, 231, 131, 124, 198, 225, 224, 98, 231, 35, 53, 42, 206, 117, 23,
				1, 143, 7, 82, 54, 52, 5, 127, 162, 52, 179, 211, 163, 10, 27, 149,
				202, 52, 153, 212, 140, 111, 79, 43, 16, 231, 225, 5, 213, 66, 95, 38,
				241, 114, 252, 156, 20, 124, 253, 29, 174, 40, 42, 198, 144, 224, 194, 120,
				109, 46, 206, 164, 134, 27, 5, 13, 141, 27, 70, 75, 105, 95, 158, 73,
				67, 104, 42, 62, 215, 97, 167, 135, 108, 9, 1, 108, 196, 83, 45, 94,
				207, 67, 87, 81, 61, 37, 169, 148, 213, 153, 94, 130, 112, 187, 236, 133,
				29, 131, 16, 122, 39, 197, 84, 19, 153, 162, 170, 6, 108, 225, 130, 217,
				67, 53, 91, 54, 195, 115, 136, 217, 254, 29, 123, 169, 200, 190, 241, 129,
				31, 120, 59, 166, 162, 208, 195, 45, 234, 124, 97, 160, 174, 248, 108, 233,
				96, 226, 5, 98, 215, 165, 192, 136, 172, 165, 9, 196, 68, 10, 126, 175,
				202, 162, 2, 152, 136, 241, 144, 209, 51, 209, 68, 46, 82, 170, 68, 213,
				149, 208, 32, 63, 217, 233, 46, 250, 194, 17, 150, 255, 158, 251, 153, 102,
				113, 67, 1, 95, 42, 164, 72, 130, 74, 143, 159, 208, 23, 127, 55, 91,
				45, 186, 23, 107, 89, 126, 194, 231, 154, 122, 220, 46, 123, 64, 185, 225,
				100, 59, 102, 138, 193, 125, 221, 184, 110, 186, 198, 54, 7, 34, 49, 49,
				87, 141, 191, 56, 55, 194, 57, 32, 157, 43, 31, 226, 201, 63, 238, 63,
				95, 254, 162, 218, 157, 94, 69, 200, 23, 193, 186, 253, 226, 37, 235, 217,
				159, 168, 87, 57, 76, 203, 31, 198, 224, 213, 178, 124, 192, 158, 198, 97,
				15, 208, 73, 70, 58, 94, 55, 127, 145, 152, 20, 63, 246, 79, 68, 173,
				43, 43, 100, 16, 198, 70, 160, 170, 153, 125, 242, 186, 75, 185, 170, 117,
				72, 40, 97, 47, 110, 5, 112, 95, 114, 210, 200, 60, 178, 47, 83, 237,
				134, 189, 14, 68, 226, 170, 138, 17, 240, 14, 154, 201, 184, 97, 43, 16,
				152, 48, 246, 194, 217, 171, 5, 173, 126, 144, 246, 122, 222, 88, 15, 40,
				168, 69, 68, 59, 141, 204, 8, 135, 24, 158, 208, 17, 175, 215, 179, 224,
				143, 191, 164, 191, 99, 176, 163, 148, 27, 113, 132, 156, 20, 67, 116, 223,
				6, 109, 40, 69, 203, 161, 84, 200, 167, 184, 122, 235, 90, 222, 226, 5,
				115, 33, 240, 111, 12, 204, 25, 213, 21, 109, 185, 97, 181, 215, 133, 129,
				64, 142, 131, 19, 170, 104, 107, 40, 120, 69, 222, 150, 150, 125, 147, 216,
				52, 154, 24, 252, 27, 210, 11, 99, 13, 8, 1, 108, 164, 99, 85, 40,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 128, 149, 226, 170, 91, 174, 16, 228, 98,
				196, 132, 187, 60, 114, 251, 118, 111, 65, 192, 249, 65, 51, 94, 229, 224,
				104, 0, 48, 243, 255, 103, 143, 5}),
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := new(Rotor).New(proFormaRotors[0].Size, proFormaRotors[0].Start, proFormaRotors[0].Size, append([]byte(nil), proFormaRotors[0].Rotor...))
			r.Update(rnd)
			if !reflect.DeepEqual(r, tt.want) {
				t.Errorf("Updated Rotor() = %v, want %v", r, tt.want)
			}
		})
	}
}

func TestRotor_sliceRotor(t *testing.T) {
	tests := []struct {
		name string
	}{
		{
			name: "trsr1",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := new(Rotor).New(1783, 863, 1033, []byte{
				184, 25, 190, 250, 35, 11, 111, 218, 111, 1, 44, 59, 137, 12, 184, 22,
				154, 226, 101, 88, 167, 109, 45, 92, 19, 164, 132, 233, 34, 133, 138, 222,
				59, 49, 123, 208, 179, 248, 61, 216, 55, 59, 235, 57, 67, 172, 233, 232,
				87, 236, 189, 170, 196, 124, 216, 109, 4, 106, 207, 150, 166, 164, 99, 57,
				131, 27, 1, 236, 168, 78, 122, 81, 165, 26, 32, 56, 129, 105, 35, 26,
				247, 208, 56, 235, 91, 183, 67, 150, 112, 103, 173, 197, 69, 13, 115, 14,
				129, 206, 74, 46, 119, 208, 95, 67, 119, 7, 191, 210, 128, 117, 140, 245,
				41, 168, 63, 203, 53, 241, 221, 28, 158, 40, 89, 76, 126, 58, 33, 40,
				78, 130, 93, 116, 206, 66, 4, 10, 109, 86, 150, 53, 200, 34, 26, 37,
				232, 185, 214, 47, 131, 18, 241, 210, 18, 81, 107, 161, 97, 65, 238, 250,
				81, 133, 54, 158, 54, 10, 254, 135, 110, 162, 175, 250, 117, 66, 232, 66,
				50, 102, 70, 76, 185, 249, 57, 59, 247, 195, 101, 8, 157, 235, 24, 94,
				204, 74, 100, 196, 93, 24, 179, 27, 118, 168, 29, 10, 38, 204, 210, 123,
				111, 247, 225, 171, 60, 166, 239, 124, 43, 180, 223, 240, 66, 2, 68, 220,
				12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
			r.sliceRotor()
			if !reflect.DeepEqual(r, proFormaRotors[0]) {
				t.Errorf("Sliced Rotor() = %v, want %v", r, proFormaRotors[0])
			}
		})
	}
}

func TestRotor_SetIndex(t *testing.T) {
	type args struct {
		idx *big.Int
	}
	tests := []struct {
		name string
		args args
		want int
	}{
		{
			name: "trsi1",
			args: args{
				idx: big.NewInt(10000),
			},
			want: 161,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := proFormaRotors[0]
			r.SetIndex(tt.args.idx)
			if r.Current != tt.want {
				t.Errorf("r.Current = %v, want %v", r.Current, tt.want)
			}
		})
	}
}

func TestRotor_Index(t *testing.T) {
	tests := []struct {
		name string
		want *big.Int
	}{
		{
			name: "trsi1",
			want: nil,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := proFormaRotors[0]
			if got := r.Index(); got != tt.want {
				t.Errorf("Rotor.Index() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestRotor_ApplyF(t *testing.T) {
	type args struct {
		blk CipherBlock
	}
	tests := []struct {
		name string
		args args
		want CipherBlock
	}{
		{
			name: "tpaf1",
			args: args{
				[]byte{
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				},
			},
			want: []byte{
				184, 25, 190, 250, 35, 11, 111, 218, 111, 1, 44, 59, 137, 12, 184, 22,
				154, 226, 101, 88, 167, 109, 45, 92, 19, 164, 132, 233, 34, 133, 138, 222,
			},
		},
		{
			name: "tpaf2",
			args: args{
				[]byte{
					0, 0, 0, 0,
				},
			},
			want: []byte{
				184, 25, 190, 250,
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := proFormaRotors[0]
			r.Current = 0
			if got := r.ApplyF(tt.args.blk); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("Rotor.ApplyF() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestRotor_ApplyG(t *testing.T) {
	type args struct {
		blk CipherBlock
	}
	tests := []struct {
		name string
		args args
		want CipherBlock
	}{
		{
			name: "tpag1",
			args: args{
				[]byte{
					184, 25, 190, 250, 35, 11, 111, 218, 111, 1, 44, 59, 137, 12, 184, 22,
					154, 226, 101, 88, 167, 109, 45, 92, 19, 164, 132, 233, 34, 133, 138, 222,
				},
			},
			want: []byte{
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			},
		},
		{
			name: "tpag2",
			args: args{
				[]byte{
					184, 25, 190, 250,
				},
			},
			want: []byte{
				0, 0, 0, 0,
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := proFormaRotors[0]
			r.Current = 0
			if got := r.ApplyG(tt.args.blk); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("Rotor.ApplyG() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestRotor_String(t *testing.T) {
	tests := []struct {
		name string
		want string
	}{
		{
			name: "trs1",
			want: "new(Rotor).New(1783, 863, 1033, []byte{\n" +
				"\t184, 25, 190, 250, 35, 11, 111, 218, 111, 1, 44, 59, 137, 12, 184, 22,\n" +
				"\t154, 226, 101, 88, 167, 109, 45, 92, 19, 164, 132, 233, 34, 133, 138, 222,\n" +
				"\t59, 49, 123, 208, 179, 248, 61, 216, 55, 59, 235, 57, 67, 172, 233, 232,\n" +
				"\t87, 236, 189, 170, 196, 124, 216, 109, 4, 106, 207, 150, 166, 164, 99, 57,\n" +
				"\t131, 27, 1, 236, 168, 78, 122, 81, 165, 26, 32, 56, 129, 105, 35, 26,\n" +
				"\t247, 208, 56, 235, 91, 183, 67, 150, 112, 103, 173, 197, 69, 13, 115, 14,\n" +
				"\t129, 206, 74, 46, 119, 208, 95, 67, 119, 7, 191, 210, 128, 117, 140, 245,\n" +
				"\t41, 168, 63, 203, 53, 241, 221, 28, 158, 40, 89, 76, 126, 58, 33, 40,\n" +
				"\t78, 130, 93, 116, 206, 66, 4, 10, 109, 86, 150, 53, 200, 34, 26, 37,\n" +
				"\t232, 185, 214, 47, 131, 18, 241, 210, 18, 81, 107, 161, 97, 65, 238, 250,\n" +
				"\t81, 133, 54, 158, 54, 10, 254, 135, 110, 162, 175, 250, 117, 66, 232, 66,\n" +
				"\t50, 102, 70, 76, 185, 249, 57, 59, 247, 195, 101, 8, 157, 235, 24, 94,\n" +
				"\t204, 74, 100, 196, 93, 24, 179, 27, 118, 168, 29, 10, 38, 204, 210, 123,\n" +
				"\t111, 247, 225, 171, 60, 166, 239, 124, 43, 180, 223, 240, 66, 2, 68, 220,\n" +
				"\t12, 95, 253, 145, 133, 55, 237, 183, 0, 150, 157, 68, 6, 92, 11, 77,\n" +
				"\t241, 50, 172, 211, 182, 22, 174, 9, 82, 194, 116, 145, 66, 69, 111, 0})\n",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := proFormaRotors[0]
			if got := r.String(); got != tt.want {
				t.Errorf("Rotor.String() = %v, want = %v", got, tt.want)
			}
		})
	}
}
