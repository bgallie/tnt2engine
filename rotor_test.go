// This is free and unencumbered software released into the public domain.
// See the UNLICENSE file for details.

package tnt2engine

import (
	"math/big"
	"reflect"
	"testing"
)

func TestNewRotor(t *testing.T) {
	type args struct {
		size  int
		start int
		step  int
		rotor []byte
	}
	tests := []struct {
		name string
		args args
		want *Rotor
	}{
		{
			name: "tnr",
			args: args{
				size:  1783,
				start: 863,
				step:  1033,
				rotor: []byte{
					184, 25, 190, 250, 35, 11, 111, 218, 111, 1, 44, 59, 137, 12, 184, 22,
					154, 226, 101, 88, 167, 109, 45, 92, 19, 164, 132, 233, 34, 133, 138, 222,
					59, 49, 123, 208, 179, 248, 61, 216, 55, 59, 235, 57, 67, 172, 233, 232,
					87, 236, 189, 170, 196, 124, 216, 109, 4, 106, 207, 150, 166, 164, 99, 57,
					131, 27, 1, 236, 168, 78, 122, 81, 165, 26, 32, 56, 129, 105, 35, 26,
					247, 208, 56, 235, 91, 183, 67, 150, 112, 103, 173, 197, 69, 13, 115, 14,
					129, 206, 74, 46, 119, 208, 95, 67, 119, 7, 191, 210, 128, 117, 140, 245,
					41, 168, 63, 203, 53, 241, 221, 28, 158, 40, 89, 76, 126, 58, 33, 40,
					78, 130, 93, 116, 206, 66, 4, 10, 109, 86, 150, 53, 200, 34, 26, 37,
					232, 185, 214, 47, 131, 18, 241, 210, 18, 81, 107, 161, 97, 65, 238, 250,
					81, 133, 54, 158, 54, 10, 254, 135, 110, 162, 175, 250, 117, 66, 232, 66,
					50, 102, 70, 76, 185, 249, 57, 59, 247, 195, 101, 8, 157, 235, 24, 94,
					204, 74, 100, 196, 93, 24, 179, 27, 118, 168, 29, 10, 38, 204, 210, 123,
					111, 247, 225, 171, 60, 166, 239, 124, 43, 180, 223, 240, 66, 2, 68, 220,
					12, 95, 253, 145, 133, 55, 237, 183, 0, 150, 157, 68, 6, 92, 11, 77,
					241, 50, 172, 211, 182, 22, 174, 9, 82, 194, 116, 145, 66, 69, 111, 0},
			},
			want: proFormaRotors[0],
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := new(Rotor).New(tt.args.size, tt.args.start, tt.args.step, tt.args.rotor); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("NewRotor() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestRotor_Update(t *testing.T) {
	tnt2Machine := new(Tnt2Engine)
	tnt2Machine.Init([]byte("SecretKey"), "")
	tnt2Machine.SetEngineType("E")
	tnt2Machine.SetIndex(BigZero)
	tnt2Machine.BuildCipherMachine()
	rnd := new(Rand).New(tnt2Machine)
	defer tnt2Machine.CloseCipherMachine()
	tests := []struct {
		name string
		want *Rotor
	}{
		{
			name: "tur1",
			want: new(Rotor).New(8081, 2314, 3676, []byte{
				231, 88, 6, 33, 169, 111, 70, 241, 37, 95, 181, 73, 119, 230, 122, 97,
				78, 245, 3, 101, 166, 155, 110, 55, 160, 148, 28, 203, 193, 27, 87, 150,
				220, 96, 207, 205, 213, 170, 17, 22, 138, 126, 71, 111, 69, 49, 155, 223,
				253, 194, 35, 33, 144, 186, 67, 211, 92, 210, 9, 53, 32, 58, 100, 171,
				255, 235, 95, 193, 111, 84, 101, 41, 217, 218, 68, 128, 66, 28, 196, 9,
				210, 177, 28, 230, 158, 56, 54, 21, 164, 34, 50, 156, 232, 211, 43, 164,
				156, 128, 94, 82, 168, 99, 251, 145, 4, 190, 35, 81, 63, 77, 23, 119,
				190, 6, 2, 47, 236, 178, 151, 195, 17, 13, 54, 109, 159, 193, 145, 4,
				147, 98, 227, 131, 28, 21, 54, 151, 236, 103, 53, 35, 141, 101, 59, 224,
				226, 180, 156, 230, 233, 66, 85, 64, 228, 203, 155, 212, 71, 103, 68, 72,
				11, 225, 132, 131, 55, 44, 87, 247, 242, 36, 168, 111, 240, 42, 23, 160,
				59, 66, 190, 120, 231, 168, 111, 184, 67, 183, 0, 107, 24, 155, 36, 7,
				247, 33, 158, 70, 216, 171, 34, 30, 38, 119, 85, 159, 209, 126, 12, 155,
				5, 149, 87, 228, 90, 244, 73, 73, 167, 144, 105, 190, 61, 122, 99, 115,
				76, 166, 240, 106, 208, 140, 116, 139, 79, 43, 71, 112, 74, 153, 139, 0,
				146, 7, 48, 97, 44, 255, 94, 53, 65, 242, 25, 12, 5, 154, 226, 180,
				255, 62, 20, 118, 28, 221, 38, 167, 33, 185, 124, 96, 139, 99, 90, 36,
				17, 238, 167, 22, 207, 197, 230, 10, 23, 22, 102, 90, 66, 242, 162, 195,
				15, 122, 245, 0, 19, 185, 255, 178, 47, 155, 100, 105, 191, 130, 52, 104,
				150, 232, 12, 97, 104, 58, 59, 77, 115, 190, 129, 153, 155, 38, 25, 184,
				158, 251, 10, 198, 27, 212, 175, 237, 241, 202, 81, 133, 244, 241, 82, 147,
				229, 100, 214, 144, 205, 235, 36, 248, 60, 5, 217, 223, 35, 244, 67, 212,
				85, 135, 31, 217, 166, 250, 97, 24, 129, 231, 154, 85, 155, 157, 57, 112,
				97, 197, 198, 119, 25, 190, 30, 155, 223, 161, 108, 15, 141, 106, 168, 130,
				73, 107, 132, 77, 124, 6, 70, 195, 195, 38, 183, 76, 67, 33, 71, 247,
				14, 38, 183, 45, 157, 88, 57, 170, 82, 28, 211, 189, 80, 23, 153, 49,
				98, 107, 234, 229, 210, 24, 155, 84, 200, 144, 41, 160, 121, 237, 91, 151,
				178, 95, 68, 169, 46, 32, 149, 44, 48, 163, 63, 144, 244, 83, 119, 162,
				177, 104, 159, 248, 219, 192, 246, 249, 97, 185, 42, 85, 158, 245, 103, 196,
				249, 237, 210, 221, 55, 108, 100, 245, 38, 93, 136, 238, 147, 182, 49, 147,
				68, 171, 54, 88, 17, 107, 224, 172, 187, 134, 253, 161, 100, 79, 90, 91,
				83, 81, 135, 126, 49, 147, 105, 73, 234, 26, 200, 99, 22, 28, 96, 19,
				120, 195, 148, 217, 254, 193, 186, 242, 230, 50, 88, 209, 155, 41, 124, 129,
				137, 36, 113, 13, 229, 103, 255, 46, 21, 186, 49, 140, 126, 22, 206, 76,
				138, 2, 119, 72, 236, 152, 11, 38, 242, 165, 245, 210, 236, 208, 75, 219,
				203, 238, 208, 137, 53, 27, 126, 183, 30, 247, 240, 246, 193, 156, 123, 5,
				244, 7, 138, 119, 150, 234, 52, 235, 20, 49, 248, 218, 101, 72, 10, 10,
				140, 3, 162, 249, 60, 156, 225, 75, 89, 150, 236, 47, 92, 64, 185, 237,
				223, 227, 74, 166, 113, 81, 100, 110, 84, 206, 137, 230, 114, 48, 229, 239,
				50, 218, 204, 112, 62, 94, 159, 29, 181, 0, 175, 135, 3, 36, 13, 3,
				202, 255, 57, 61, 179, 183, 93, 148, 180, 235, 245, 103, 2, 213, 208, 104,
				190, 200, 251, 18, 4, 8, 92, 82, 91, 10, 157, 91, 231, 24, 127, 25,
				194, 235, 237, 110, 249, 220, 231, 0, 9, 185, 221, 110, 21, 35, 41, 39,
				57, 104, 47, 114, 18, 232, 158, 126, 184, 179, 229, 126, 156, 183, 157, 28,
				196, 250, 45, 5, 169, 95, 100, 108, 33, 97, 252, 59, 140, 15, 26, 137,
				67, 172, 160, 223, 120, 91, 247, 66, 47, 54, 137, 98, 111, 28, 97, 169,
				211, 56, 27, 253, 65, 209, 108, 74, 211, 119, 86, 184, 248, 51, 33, 231,
				87, 183, 253, 174, 140, 57, 64, 13, 236, 43, 234, 58, 48, 200, 182, 248,
				47, 202, 104, 216, 156, 23, 164, 245, 13, 79, 86, 141, 162, 71, 141, 193,
				200, 160, 118, 67, 97, 18, 34, 165, 160, 179, 246, 167, 184, 183, 97, 56,
				14, 191, 86, 33, 189, 18, 75, 173, 59, 233, 60, 204, 4, 147, 33, 87,
				142, 207, 39, 20, 92, 203, 96, 70, 3, 111, 203, 16, 99, 71, 192, 28,
				252, 237, 161, 18, 126, 134, 98, 59, 244, 174, 37, 71, 184, 150, 240, 178,
				189, 49, 155, 125, 24, 8, 146, 149, 253, 183, 59, 215, 5, 191, 53, 241,
				210, 77, 120, 4, 197, 32, 117, 174, 224, 131, 235, 245, 107, 78, 40, 150,
				252, 39, 241, 112, 136, 97, 219, 237, 173, 192, 160, 201, 225, 250, 67, 241,
				120, 181, 182, 219, 73, 122, 171, 28, 5, 250, 174, 240, 101, 43, 137, 217,
				175, 15, 50, 136, 215, 45, 132, 23, 228, 196, 189, 238, 148, 27, 2, 239,
				5, 25, 46, 237, 207, 55, 145, 146, 181, 236, 109, 35, 80, 120, 206, 70,
				219, 244, 25, 104, 204, 211, 95, 156, 241, 219, 153, 76, 93, 205, 230, 111,
				137, 46, 121, 34, 166, 50, 105, 105, 63, 122, 96, 55, 204, 133, 240, 255,
				195, 7, 84, 57, 200, 77, 64, 181, 189, 91, 140, 56, 49, 134, 14, 37,
				125, 114, 35, 227, 90, 241, 248, 160, 17, 181, 153, 53, 24, 232, 22, 86,
				224, 170, 206, 177, 12, 66, 82, 223, 140, 226, 75, 190, 106, 147, 238, 204,
				245, 194, 156, 234, 7, 202, 76, 55, 221, 110, 64, 41, 57, 150, 131, 55,
				174, 44, 1}),
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := new(Rotor).New(proFormaRotors[0].Size, proFormaRotors[0].Start, proFormaRotors[0].Size, append([]byte(nil), proFormaRotors[0].Rotor...))
			r.Update(rnd)
			if !reflect.DeepEqual(r, tt.want) {
				t.Errorf("Updated Rotor() = %v, want %v", r, tt.want)
			}
		})
	}
}

func TestRotor_sliceRotor(t *testing.T) {
	tests := []struct {
		name string
	}{
		{
			name: "trsr1",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := new(Rotor).New(1783, 863, 1033, []byte{
				184, 25, 190, 250, 35, 11, 111, 218, 111, 1, 44, 59, 137, 12, 184, 22,
				154, 226, 101, 88, 167, 109, 45, 92, 19, 164, 132, 233, 34, 133, 138, 222,
				59, 49, 123, 208, 179, 248, 61, 216, 55, 59, 235, 57, 67, 172, 233, 232,
				87, 236, 189, 170, 196, 124, 216, 109, 4, 106, 207, 150, 166, 164, 99, 57,
				131, 27, 1, 236, 168, 78, 122, 81, 165, 26, 32, 56, 129, 105, 35, 26,
				247, 208, 56, 235, 91, 183, 67, 150, 112, 103, 173, 197, 69, 13, 115, 14,
				129, 206, 74, 46, 119, 208, 95, 67, 119, 7, 191, 210, 128, 117, 140, 245,
				41, 168, 63, 203, 53, 241, 221, 28, 158, 40, 89, 76, 126, 58, 33, 40,
				78, 130, 93, 116, 206, 66, 4, 10, 109, 86, 150, 53, 200, 34, 26, 37,
				232, 185, 214, 47, 131, 18, 241, 210, 18, 81, 107, 161, 97, 65, 238, 250,
				81, 133, 54, 158, 54, 10, 254, 135, 110, 162, 175, 250, 117, 66, 232, 66,
				50, 102, 70, 76, 185, 249, 57, 59, 247, 195, 101, 8, 157, 235, 24, 94,
				204, 74, 100, 196, 93, 24, 179, 27, 118, 168, 29, 10, 38, 204, 210, 123,
				111, 247, 225, 171, 60, 166, 239, 124, 43, 180, 223, 240, 66, 2, 68, 220,
				12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
			r.sliceRotor()
			if !reflect.DeepEqual(r, proFormaRotors[0]) {
				t.Errorf("Sliced Rotor() = %v, want %v", r, proFormaRotors[0])
			}
		})
	}
}

func TestRotor_SetIndex(t *testing.T) {
	type args struct {
		idx *big.Int
	}
	tests := []struct {
		name string
		args args
		want int
	}{
		{
			name: "trsi1",
			args: args{
				idx: big.NewInt(10000),
			},
			want: 161,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := proFormaRotors[0]
			r.SetIndex(tt.args.idx)
			if r.Current != tt.want {
				t.Errorf("r.Current = %v, want %v", r.Current, tt.want)
			}
		})
	}
}

func TestRotor_Index(t *testing.T) {
	tests := []struct {
		name string
		want *big.Int
	}{
		{
			name: "trsi1",
			want: nil,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := proFormaRotors[0]
			if got := r.Index(); got != tt.want {
				t.Errorf("Rotor.Index() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestRotor_ApplyF(t *testing.T) {
	type args struct {
		blk CipherBlock
	}
	tests := []struct {
		name string
		args args
		want CipherBlock
	}{
		{
			name: "tpaf1",
			args: args{
				[]byte{
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				},
			},
			want: []byte{
				184, 25, 190, 250, 35, 11, 111, 218, 111, 1, 44, 59, 137, 12, 184, 22,
				154, 226, 101, 88, 167, 109, 45, 92, 19, 164, 132, 233, 34, 133, 138, 222,
			},
		},
		{
			name: "tpaf2",
			args: args{
				[]byte{
					0, 0, 0, 0,
				},
			},
			want: []byte{
				184, 25, 190, 250,
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := proFormaRotors[0]
			r.Current = 0
			if got := r.ApplyF(tt.args.blk); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("Rotor.ApplyF() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestRotor_ApplyG(t *testing.T) {
	type args struct {
		blk CipherBlock
	}
	tests := []struct {
		name string
		args args
		want CipherBlock
	}{
		{
			name: "tpag1",
			args: args{
				[]byte{
					184, 25, 190, 250, 35, 11, 111, 218, 111, 1, 44, 59, 137, 12, 184, 22,
					154, 226, 101, 88, 167, 109, 45, 92, 19, 164, 132, 233, 34, 133, 138, 222,
				},
			},
			want: []byte{
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			},
		},
		{
			name: "tpag2",
			args: args{
				[]byte{
					184, 25, 190, 250,
				},
			},
			want: []byte{
				0, 0, 0, 0,
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := proFormaRotors[0]
			r.Current = 0
			if got := r.ApplyG(tt.args.blk); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("Rotor.ApplyG() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestRotor_String(t *testing.T) {
	tests := []struct {
		name string
		want string
	}{
		{
			name: "trs1",
			want: "new(Rotor).New(1783, 863, 1033, []byte{\n" +
				"\t184, 25, 190, 250, 35, 11, 111, 218, 111, 1, 44, 59, 137, 12, 184, 22, \n" +
				"\t154, 226, 101, 88, 167, 109, 45, 92, 19, 164, 132, 233, 34, 133, 138, 222, \n" +
				"\t59, 49, 123, 208, 179, 248, 61, 216, 55, 59, 235, 57, 67, 172, 233, 232, \n" +
				"\t87, 236, 189, 170, 196, 124, 216, 109, 4, 106, 207, 150, 166, 164, 99, 57, \n" +
				"\t131, 27, 1, 236, 168, 78, 122, 81, 165, 26, 32, 56, 129, 105, 35, 26, \n" +
				"\t247, 208, 56, 235, 91, 183, 67, 150, 112, 103, 173, 197, 69, 13, 115, 14, \n" +
				"\t129, 206, 74, 46, 119, 208, 95, 67, 119, 7, 191, 210, 128, 117, 140, 245, \n" +
				"\t41, 168, 63, 203, 53, 241, 221, 28, 158, 40, 89, 76, 126, 58, 33, 40, \n" +
				"\t78, 130, 93, 116, 206, 66, 4, 10, 109, 86, 150, 53, 200, 34, 26, 37, \n" +
				"\t232, 185, 214, 47, 131, 18, 241, 210, 18, 81, 107, 161, 97, 65, 238, 250, \n" +
				"\t81, 133, 54, 158, 54, 10, 254, 135, 110, 162, 175, 250, 117, 66, 232, 66, \n" +
				"\t50, 102, 70, 76, 185, 249, 57, 59, 247, 195, 101, 8, 157, 235, 24, 94, \n" +
				"\t204, 74, 100, 196, 93, 24, 179, 27, 118, 168, 29, 10, 38, 204, 210, 123, \n" +
				"\t111, 247, 225, 171, 60, 166, 239, 124, 43, 180, 223, 240, 66, 2, 68, 220, \n" +
				"\t12, 95, 253, 145, 133, 55, 237, 183, 0, 150, 157, 68, 6, 92, 11, 77, \n" +
				"\t241, 50, 172, 211, 182, 22, 174, 9, 82, 194, 116, 145, 66, 69, 111, 0})\n",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := proFormaRotors[0]
			if got := r.String(); got != tt.want {
				t.Errorf("Rotor.String() = %v, want = %v", got, tt.want)
			}
		})
	}
}
