// This is free and unencumbered software released into the public domain.
// See the UNLICENSE file for details.

package tnt2engine

import (
	"math/big"
	"reflect"
	"testing"
)

func TestNewRotor(t *testing.T) {
	type args struct {
		size  int
		start int
		step  int
		rotor []byte
	}
	tests := []struct {
		name string
		args args
		want *Rotor
	}{
		{
			name: "tnr",
			args: args{
				size:  1783,
				start: 863,
				step:  1033,
				rotor: []byte{
					184, 25, 190, 250, 35, 11, 111, 218, 111, 1, 44, 59, 137, 12, 184, 22,
					154, 226, 101, 88, 167, 109, 45, 92, 19, 164, 132, 233, 34, 133, 138, 222,
					59, 49, 123, 208, 179, 248, 61, 216, 55, 59, 235, 57, 67, 172, 233, 232,
					87, 236, 189, 170, 196, 124, 216, 109, 4, 106, 207, 150, 166, 164, 99, 57,
					131, 27, 1, 236, 168, 78, 122, 81, 165, 26, 32, 56, 129, 105, 35, 26,
					247, 208, 56, 235, 91, 183, 67, 150, 112, 103, 173, 197, 69, 13, 115, 14,
					129, 206, 74, 46, 119, 208, 95, 67, 119, 7, 191, 210, 128, 117, 140, 245,
					41, 168, 63, 203, 53, 241, 221, 28, 158, 40, 89, 76, 126, 58, 33, 40,
					78, 130, 93, 116, 206, 66, 4, 10, 109, 86, 150, 53, 200, 34, 26, 37,
					232, 185, 214, 47, 131, 18, 241, 210, 18, 81, 107, 161, 97, 65, 238, 250,
					81, 133, 54, 158, 54, 10, 254, 135, 110, 162, 175, 250, 117, 66, 232, 66,
					50, 102, 70, 76, 185, 249, 57, 59, 247, 195, 101, 8, 157, 235, 24, 94,
					204, 74, 100, 196, 93, 24, 179, 27, 118, 168, 29, 10, 38, 204, 210, 123,
					111, 247, 225, 171, 60, 166, 239, 124, 43, 180, 223, 240, 66, 2, 68, 220,
					12, 95, 253, 145, 133, 55, 237, 183, 0, 150, 157, 68, 6, 92, 11, 77,
					241, 50, 172, 211, 182, 22, 174, 9, 82, 194, 116, 145, 66, 69, 111, 0},
			},
			want: proFormaRotors[0],
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := new(Rotor).New(tt.args.size, tt.args.start, tt.args.step, tt.args.rotor); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("NewRotor() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestRotor_Update(t *testing.T) {
	tnt2Machine := new(Tnt2Engine)
	tnt2Machine.Init([]byte("SecretKey"), "")
	tnt2Machine.SetEngineType("E")
	tnt2Machine.SetIndex(BigZero)
	tnt2Machine.BuildCipherMachine()
	rnd := new(Rand).New(tnt2Machine)
	defer tnt2Machine.CloseCipherMachine()
	tests := []struct {
		name string
		want *Rotor
	}{
		{
			name: "tur1",
			want: new(Rotor).New(8123, 125, 2174, []byte{
				243, 129, 174, 233, 173, 25, 120, 233, 54, 204, 94, 31, 103, 147, 44, 11,
				193, 105, 192, 63, 4, 127, 92, 151, 143, 61, 229, 36, 176, 82, 160, 165,
				147, 197, 176, 41, 11, 158, 104, 15, 79, 13, 3, 55, 50, 7, 130, 225,
				221, 191, 104, 152, 219, 25, 107, 174, 135, 15, 152, 27, 48, 111, 132, 143,
				160, 3, 97, 247, 38, 137, 185, 84, 78, 212, 46, 233, 23, 212, 100, 119,
				73, 229, 123, 228, 116, 65, 10, 74, 151, 0, 204, 128, 207, 86, 198, 207,
				232, 53, 202, 24, 93, 45, 154, 91, 254, 208, 124, 111, 113, 187, 165, 214,
				146, 119, 35, 3, 108, 124, 251, 27, 119, 250, 151, 8, 83, 151, 25, 245,
				206, 21, 65, 74, 80, 195, 214, 27, 43, 136, 211, 7, 172, 151, 225, 179,
				131, 146, 54, 215, 66, 108, 238, 125, 222, 167, 53, 61, 224, 46, 52, 10,
				74, 185, 48, 13, 153, 170, 152, 147, 60, 170, 52, 43, 84, 147, 170, 39,
				161, 234, 166, 232, 45, 108, 12, 108, 11, 215, 109, 80, 222, 68, 66, 19,
				233, 30, 239, 49, 138, 10, 206, 171, 68, 253, 194, 168, 82, 99, 147, 161,
				207, 118, 92, 201, 151, 199, 137, 21, 45, 75, 40, 21, 93, 115, 66, 124,
				61, 9, 146, 1, 168, 202, 231, 208, 52, 143, 221, 91, 181, 79, 43, 30,
				237, 29, 210, 172, 171, 190, 125, 92, 159, 156, 248, 51, 26, 214, 220, 33,
				84, 85, 48, 221, 157, 242, 247, 18, 99, 166, 131, 5, 208, 249, 172, 83,
				49, 233, 55, 223, 225, 14, 118, 182, 65, 205, 225, 195, 241, 0, 80, 16,
				16, 63, 199, 27, 163, 186, 127, 155, 79, 230, 64, 85, 126, 64, 166, 26,
				32, 118, 202, 145, 106, 116, 179, 184, 57, 235, 22, 131, 131, 222, 242, 198,
				176, 253, 7, 220, 126, 201, 176, 117, 64, 209, 70, 79, 171, 123, 69, 63,
				231, 188, 33, 252, 115, 175, 81, 72, 19, 80, 179, 188, 117, 108, 239, 142,
				181, 179, 234, 92, 25, 104, 3, 230, 80, 217, 237, 62, 150, 160, 132, 110,
				85, 190, 94, 27, 128, 233, 140, 107, 181, 252, 33, 151, 37, 195, 49, 141,
				36, 18, 114, 77, 233, 91, 142, 133, 140, 179, 30, 52, 251, 240, 235, 24,
				39, 126, 98, 5, 98, 148, 23, 60, 124, 74, 145, 253, 251, 191, 253, 233,
				5, 30, 230, 108, 110, 191, 41, 237, 44, 14, 183, 111, 131, 76, 202, 179,
				246, 31, 170, 94, 110, 56, 121, 60, 78, 160, 97, 178, 47, 153, 202, 32,
				121, 86, 60, 53, 184, 16, 46, 231, 131, 176, 24, 139, 127, 238, 243, 45,
				219, 193, 233, 130, 173, 158, 74, 40, 175, 116, 185, 156, 87, 167, 248, 135,
				118, 100, 181, 24, 133, 180, 177, 232, 118, 63, 225, 145, 53, 204, 144, 6,
				16, 214, 24, 147, 141, 32, 252, 76, 230, 1, 239, 86, 78, 65, 140, 112,
				16, 203, 36, 118, 245, 95, 239, 231, 150, 12, 162, 153, 27, 129, 104, 219,
				194, 31, 44, 237, 107, 195, 248, 160, 124, 163, 184, 202, 50, 206, 197, 30,
				47, 144, 84, 77, 240, 242, 194, 169, 140, 55, 56, 157, 106, 209, 107, 154,
				90, 95, 205, 255, 49, 18, 79, 113, 237, 207, 189, 33, 61, 199, 184, 100,
				74, 19, 250, 96, 119, 59, 30, 235, 26, 222, 71, 155, 168, 67, 136, 228,
				13, 1, 246, 162, 235, 167, 122, 150, 170, 229, 149, 5, 88, 23, 181, 42,
				245, 219, 136, 62, 253, 241, 129, 130, 77, 67, 96, 11, 37, 230, 149, 167,
				164, 17, 119, 232, 216, 228, 159, 11, 170, 94, 93, 186, 221, 161, 44, 208,
				248, 48, 148, 181, 77, 18, 229, 243, 147, 49, 70, 124, 82, 82, 152, 122,
				47, 45, 174, 174, 0, 55, 63, 104, 54, 153, 158, 68, 2, 104, 164, 103,
				168, 240, 124, 4, 4, 156, 51, 35, 61, 32, 23, 211, 107, 12, 8, 179,
				138, 5, 62, 161, 228, 76, 242, 153, 154, 128, 96, 24, 186, 217, 168, 78,
				17, 93, 115, 146, 134, 219, 38, 135, 31, 184, 111, 205, 54, 68, 37, 76,
				37, 122, 79, 180, 188, 38, 77, 109, 122, 108, 217, 103, 90, 143, 1, 232,
				26, 83, 100, 8, 28, 250, 133, 225, 8, 149, 14, 198, 174, 198, 66, 108,
				64, 175, 225, 253, 99, 195, 197, 216, 86, 235, 169, 192, 173, 162, 3, 162,
				28, 187, 249, 97, 53, 218, 73, 133, 33, 94, 245, 115, 248, 85, 81, 235,
				14, 84, 204, 211, 216, 108, 75, 17, 43, 196, 172, 66, 146, 63, 165, 238,
				245, 102, 153, 157, 86, 246, 207, 96, 238, 3, 42, 169, 25, 190, 99, 39,
				241, 80, 86, 132, 166, 138, 179, 73, 241, 225, 26, 69, 189, 38, 221, 100,
				154, 109, 97, 75, 132, 170, 233, 125, 108, 187, 178, 152, 27, 174, 135, 115,
				13, 233, 192, 47, 204, 120, 54, 59, 177, 174, 185, 100, 47, 140, 18, 10,
				114, 73, 157, 25, 227, 116, 73, 193, 221, 77, 26, 20, 46, 41, 98, 174,
				41, 172, 223, 58, 169, 219, 208, 105, 84, 240, 197, 189, 238, 118, 234, 114,
				208, 44, 244, 212, 111, 181, 124, 156, 72, 71, 99, 128, 19, 165, 52, 52,
				234, 237, 201, 84, 78, 139, 145, 228, 211, 255, 26, 205, 55, 227, 116, 151,
				157, 235, 36, 73, 125, 162, 3, 232, 53, 72, 98, 144, 7, 190, 222, 10,
				107, 227, 138, 83, 199, 172, 9, 101, 36, 15, 28, 45, 173, 129, 252, 248,
				188, 135, 228, 121, 250, 55, 56, 111, 165, 245, 87, 141, 208, 111, 41, 43,
				132, 228, 26, 213, 244, 99, 128, 63, 250, 158, 85, 196, 189, 125, 109, 51,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 152, 15, 116, 77, 111, 205, 192, 75, 183,
				97, 246, 250, 56, 155, 100, 89, 8, 78, 3, 254, 33, 248, 227, 186, 124,
				236, 41, 39, 129, 149, 2, 45, 5}),
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := new(Rotor).New(proFormaRotors[0].Size, proFormaRotors[0].Start, proFormaRotors[0].Size, append([]byte(nil), proFormaRotors[0].Rotor...))
			r.Update(rnd)
			if !reflect.DeepEqual(r, tt.want) {
				t.Errorf("Updated Rotor() = %v, want %v", r, tt.want)
			}
		})
	}
}

func TestRotor_sliceRotor(t *testing.T) {
	tests := []struct {
		name string
	}{
		{
			name: "trsr1",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := new(Rotor).New(1783, 863, 1033, []byte{
				184, 25, 190, 250, 35, 11, 111, 218, 111, 1, 44, 59, 137, 12, 184, 22,
				154, 226, 101, 88, 167, 109, 45, 92, 19, 164, 132, 233, 34, 133, 138, 222,
				59, 49, 123, 208, 179, 248, 61, 216, 55, 59, 235, 57, 67, 172, 233, 232,
				87, 236, 189, 170, 196, 124, 216, 109, 4, 106, 207, 150, 166, 164, 99, 57,
				131, 27, 1, 236, 168, 78, 122, 81, 165, 26, 32, 56, 129, 105, 35, 26,
				247, 208, 56, 235, 91, 183, 67, 150, 112, 103, 173, 197, 69, 13, 115, 14,
				129, 206, 74, 46, 119, 208, 95, 67, 119, 7, 191, 210, 128, 117, 140, 245,
				41, 168, 63, 203, 53, 241, 221, 28, 158, 40, 89, 76, 126, 58, 33, 40,
				78, 130, 93, 116, 206, 66, 4, 10, 109, 86, 150, 53, 200, 34, 26, 37,
				232, 185, 214, 47, 131, 18, 241, 210, 18, 81, 107, 161, 97, 65, 238, 250,
				81, 133, 54, 158, 54, 10, 254, 135, 110, 162, 175, 250, 117, 66, 232, 66,
				50, 102, 70, 76, 185, 249, 57, 59, 247, 195, 101, 8, 157, 235, 24, 94,
				204, 74, 100, 196, 93, 24, 179, 27, 118, 168, 29, 10, 38, 204, 210, 123,
				111, 247, 225, 171, 60, 166, 239, 124, 43, 180, 223, 240, 66, 2, 68, 220,
				12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
			r.sliceRotor()
			if !reflect.DeepEqual(r, proFormaRotors[0]) {
				t.Errorf("Sliced Rotor() = %v, want %v", r, proFormaRotors[0])
			}
		})
	}
}

func TestRotor_SetIndex(t *testing.T) {
	type args struct {
		idx *big.Int
	}
	tests := []struct {
		name string
		args args
		want int
	}{
		{
			name: "trsi1",
			args: args{
				idx: big.NewInt(10000),
			},
			want: 161,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := proFormaRotors[0]
			r.SetIndex(tt.args.idx)
			if r.Current != tt.want {
				t.Errorf("r.Current = %v, want %v", r.Current, tt.want)
			}
		})
	}
}

func TestRotor_Index(t *testing.T) {
	tests := []struct {
		name string
		want *big.Int
	}{
		{
			name: "trsi1",
			want: nil,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := proFormaRotors[0]
			if got := r.Index(); got != tt.want {
				t.Errorf("Rotor.Index() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestRotor_ApplyF(t *testing.T) {
	type args struct {
		blk CipherBlock
	}
	tests := []struct {
		name string
		args args
		want CipherBlock
	}{
		{
			name: "tpaf1",
			args: args{
				[]byte{
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				},
			},
			want: []byte{
				184, 25, 190, 250, 35, 11, 111, 218, 111, 1, 44, 59, 137, 12, 184, 22,
				154, 226, 101, 88, 167, 109, 45, 92, 19, 164, 132, 233, 34, 133, 138, 222,
			},
		},
		{
			name: "tpaf2",
			args: args{
				[]byte{
					0, 0, 0, 0,
				},
			},
			want: []byte{
				193, 46, 58, 103,
			},
		},
	}
	r := new(Rotor).New(proFormaRotors[0].Size, proFormaRotors[0].Start,
		proFormaRotors[0].Step, append([]byte(nil), proFormaRotors[0].Rotor...))
	r.Current = 0
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := r.ApplyF(tt.args.blk); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("Rotor.ApplyF() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestRotor_ApplyG(t *testing.T) {
	type args struct {
		blk CipherBlock
	}
	tests := []struct {
		name string
		args args
		want CipherBlock
	}{
		{
			name: "tpag1",
			args: args{
				[]byte{
					184, 25, 190, 250, 35, 11, 111, 218, 111, 1, 44, 59, 137, 12, 184, 22,
					154, 226, 101, 88, 167, 109, 45, 92, 19, 164, 132, 233, 34, 133, 138, 222,
				},
			},
			want: []byte{
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			},
		},
		{
			name: "tpag2",
			args: args{
				[]byte{
					193, 46, 58, 103,
				},
			},
			want: []byte{
				0, 0, 0, 0,
			},
		},
	}
	r := new(Rotor).New(proFormaRotors[0].Size, proFormaRotors[0].Start,
		proFormaRotors[0].Step, append([]byte(nil), proFormaRotors[0].Rotor...))
	r.Current = 0
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := r.ApplyG(tt.args.blk); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("Rotor.ApplyG() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestRotor_String(t *testing.T) {
	tests := []struct {
		name string
		want string
	}{
		{
			name: "trs1",
			want: "new(Rotor).New(1783, 863, 1033, []byte{\n" +
				"\t184, 25, 190, 250, 35, 11, 111, 218, 111, 1, 44, 59, 137, 12, 184, 22,\n" +
				"\t154, 226, 101, 88, 167, 109, 45, 92, 19, 164, 132, 233, 34, 133, 138, 222,\n" +
				"\t59, 49, 123, 208, 179, 248, 61, 216, 55, 59, 235, 57, 67, 172, 233, 232,\n" +
				"\t87, 236, 189, 170, 196, 124, 216, 109, 4, 106, 207, 150, 166, 164, 99, 57,\n" +
				"\t131, 27, 1, 236, 168, 78, 122, 81, 165, 26, 32, 56, 129, 105, 35, 26,\n" +
				"\t247, 208, 56, 235, 91, 183, 67, 150, 112, 103, 173, 197, 69, 13, 115, 14,\n" +
				"\t129, 206, 74, 46, 119, 208, 95, 67, 119, 7, 191, 210, 128, 117, 140, 245,\n" +
				"\t41, 168, 63, 203, 53, 241, 221, 28, 158, 40, 89, 76, 126, 58, 33, 40,\n" +
				"\t78, 130, 93, 116, 206, 66, 4, 10, 109, 86, 150, 53, 200, 34, 26, 37,\n" +
				"\t232, 185, 214, 47, 131, 18, 241, 210, 18, 81, 107, 161, 97, 65, 238, 250,\n" +
				"\t81, 133, 54, 158, 54, 10, 254, 135, 110, 162, 175, 250, 117, 66, 232, 66,\n" +
				"\t50, 102, 70, 76, 185, 249, 57, 59, 247, 195, 101, 8, 157, 235, 24, 94,\n" +
				"\t204, 74, 100, 196, 93, 24, 179, 27, 118, 168, 29, 10, 38, 204, 210, 123,\n" +
				"\t111, 247, 225, 171, 60, 166, 239, 124, 43, 180, 223, 240, 66, 2, 68, 220,\n" +
				"\t12, 95, 253, 145, 133, 55, 237, 183, 0, 150, 157, 68, 6, 92, 11, 77,\n" +
				"\t241, 50, 172, 211, 182, 22, 174, 9, 82, 194, 116, 145, 66, 69, 111, 0})\n",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := proFormaRotors[0]
			if got := r.String(); got != tt.want {
				t.Errorf("Rotor.String() = %v, want = %v", got, tt.want)
			}
		})
	}
}
