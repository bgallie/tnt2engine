// This is free and unencumbered software released into the public domain.
// See the UNLICENSE file for details.

package tnt2engine

import (
	"math/big"
	"reflect"
	"testing"
)

func TestNewRotor(t *testing.T) {
	type args struct {
		size  int
		start int
		step  int
		rotor []byte
	}
	tests := []struct {
		name string
		args args
		want *Rotor
	}{
		{
			name: "tnr",
			args: args{
				size:  1783,
				start: 863,
				step:  1033,
				rotor: []byte{
					184, 25, 190, 250, 35, 11, 111, 218, 111, 1, 44, 59, 137, 12, 184, 22,
					154, 226, 101, 88, 167, 109, 45, 92, 19, 164, 132, 233, 34, 133, 138, 222,
					59, 49, 123, 208, 179, 248, 61, 216, 55, 59, 235, 57, 67, 172, 233, 232,
					87, 236, 189, 170, 196, 124, 216, 109, 4, 106, 207, 150, 166, 164, 99, 57,
					131, 27, 1, 236, 168, 78, 122, 81, 165, 26, 32, 56, 129, 105, 35, 26,
					247, 208, 56, 235, 91, 183, 67, 150, 112, 103, 173, 197, 69, 13, 115, 14,
					129, 206, 74, 46, 119, 208, 95, 67, 119, 7, 191, 210, 128, 117, 140, 245,
					41, 168, 63, 203, 53, 241, 221, 28, 158, 40, 89, 76, 126, 58, 33, 40,
					78, 130, 93, 116, 206, 66, 4, 10, 109, 86, 150, 53, 200, 34, 26, 37,
					232, 185, 214, 47, 131, 18, 241, 210, 18, 81, 107, 161, 97, 65, 238, 250,
					81, 133, 54, 158, 54, 10, 254, 135, 110, 162, 175, 250, 117, 66, 232, 66,
					50, 102, 70, 76, 185, 249, 57, 59, 247, 195, 101, 8, 157, 235, 24, 94,
					204, 74, 100, 196, 93, 24, 179, 27, 118, 168, 29, 10, 38, 204, 210, 123,
					111, 247, 225, 171, 60, 166, 239, 124, 43, 180, 223, 240, 66, 2, 68, 220,
					12, 95, 253, 145, 133, 55, 237, 183, 0, 150, 157, 68, 6, 92, 11, 77,
					241, 50, 172, 211, 182, 22, 174, 9, 82, 194, 116, 145, 66, 69, 111, 0},
			},
			want: proFormaRotors[0],
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := new(Rotor).New(tt.args.size, tt.args.start, tt.args.step, tt.args.rotor); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("NewRotor() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestRotor_Update(t *testing.T) {
	tnt2Machine := new(Tnt2Engine)
	tnt2Machine.Init([]byte("SecretKey"), "")
	tnt2Machine.SetEngineType("E")
	tnt2Machine.SetIndex(BigZero)
	tnt2Machine.BuildCipherMachine()
	rnd := new(Rand).New(tnt2Machine)
	defer tnt2Machine.CloseCipherMachine()
	tests := []struct {
		name string
		want *Rotor
	}{
		{
			name: "tur1",
			want: new(Rotor).New(8123, 3811, 921, []byte{
				225, 42, 94, 179, 142, 217, 0, 69, 226, 28, 114, 173, 126, 204, 176, 93,
				64, 11, 170, 139, 168, 249, 203, 183, 137, 119, 193, 144, 26, 85, 11, 214,
				75, 114, 145, 53, 251, 170, 152, 198, 64, 96, 71, 8, 106, 84, 114, 225,
				56, 190, 216, 37, 95, 156, 55, 140, 107, 67, 148, 201, 45, 226, 149, 219,
				117, 83, 186, 48, 87, 34, 66, 105, 81, 22, 190, 81, 3, 127, 116, 92,
				231, 81, 116, 250, 34, 44, 200, 82, 193, 122, 168, 141, 7, 146, 143, 241,
				209, 204, 218, 218, 126, 129, 122, 200, 97, 66, 96, 252, 40, 55, 67, 251,
				29, 156, 74, 115, 3, 28, 222, 190, 30, 176, 167, 73, 4, 109, 140, 90,
				239, 241, 22, 115, 181, 37, 196, 131, 90, 145, 15, 27, 196, 141, 143, 51,
				248, 225, 188, 119, 237, 32, 22, 176, 166, 161, 63, 133, 204, 220, 215, 191,
				7, 27, 48, 196, 205, 197, 252, 95, 158, 95, 86, 114, 108, 206, 203, 248,
				157, 195, 51, 184, 174, 225, 46, 104, 56, 113, 74, 229, 147, 166, 151, 60,
				211, 105, 22, 40, 125, 100, 210, 201, 15, 21, 141, 212, 59, 169, 145, 28,
				10, 31, 106, 60, 217, 82, 29, 26, 88, 245, 61, 155, 215, 52, 172, 49,
				255, 99, 132, 213, 223, 70, 206, 4, 75, 146, 94, 227, 57, 135, 251, 196,
				96, 60, 54, 219, 47, 247, 249, 233, 184, 227, 136, 9, 221, 32, 223, 85,
				194, 33, 232, 135, 26, 136, 152, 211, 118, 56, 189, 58, 102, 125, 63, 222,
				151, 137, 152, 229, 107, 109, 226, 157, 58, 133, 168, 232, 56, 174, 85, 197,
				142, 186, 78, 56, 241, 146, 21, 25, 59, 84, 64, 27, 128, 53, 245, 130,
				128, 62, 58, 81, 137, 174, 86, 165, 246, 225, 113, 102, 143, 92, 128, 22,
				164, 225, 206, 106, 238, 109, 224, 28, 160, 69, 18, 209, 167, 30, 192, 55,
				16, 211, 6, 13, 135, 59, 37, 113, 39, 57, 7, 160, 84, 118, 184, 144,
				117, 71, 143, 248, 143, 89, 52, 145, 220, 82, 134, 202, 241, 112, 149, 145,
				169, 110, 101, 103, 108, 177, 243, 53, 127, 92, 52, 81, 229, 162, 98, 64,
				23, 68, 8, 5, 100, 186, 180, 183, 196, 207, 75, 184, 170, 158, 227, 101,
				69, 145, 137, 224, 161, 144, 94, 210, 36, 147, 227, 51, 10, 53, 250, 232,
				189, 144, 40, 96, 204, 173, 107, 114, 142, 119, 214, 132, 227, 141, 20, 195,
				121, 223, 24, 160, 186, 192, 195, 236, 23, 253, 177, 61, 227, 231, 139, 159,
				78, 76, 74, 121, 92, 152, 40, 1, 1, 102, 76, 54, 84, 144, 226, 85,
				228, 75, 14, 116, 8, 123, 54, 219, 12, 7, 106, 56, 168, 130, 162, 146,
				83, 204, 250, 251, 118, 83, 61, 113, 12, 41, 223, 188, 151, 137, 33, 157,
				19, 201, 162, 214, 3, 250, 187, 178, 251, 62, 215, 44, 34, 211, 201, 151,
				129, 112, 41, 253, 254, 142, 110, 131, 30, 32, 92, 75, 227, 38, 246, 237,
				64, 243, 207, 48, 114, 72, 120, 100, 3, 115, 35, 29, 250, 191, 8, 148,
				163, 96, 50, 214, 183, 70, 248, 248, 198, 41, 92, 150, 112, 88, 203, 102,
				188, 40, 187, 40, 11, 114, 205, 127, 27, 247, 218, 12, 180, 114, 184, 188,
				184, 196, 148, 79, 77, 155, 6, 227, 33, 44, 147, 11, 9, 91, 131, 168,
				139, 78, 90, 50, 150, 236, 57, 41, 9, 226, 226, 10, 62, 42, 37, 170,
				150, 228, 21, 228, 184, 17, 235, 109, 71, 135, 210, 232, 113, 36, 123, 239,
				148, 95, 67, 241, 5, 19, 185, 61, 90, 111, 233, 160, 120, 85, 233, 238,
				228, 7, 70, 16, 32, 29, 252, 216, 154, 232, 90, 40, 4, 147, 20, 156,
				168, 215, 103, 145, 68, 183, 252, 224, 6, 70, 130, 94, 60, 5, 200, 245,
				6, 184, 217, 152, 160, 76, 216, 73, 15, 143, 130, 133, 111, 10, 113, 96,
				107, 196, 54, 229, 32, 110, 97, 51, 31, 232, 26, 121, 87, 80, 239, 68,
				154, 58, 163, 15, 10, 102, 167, 255, 79, 73, 9, 37, 107, 216, 90, 187,
				113, 209, 234, 203, 35, 197, 194, 18, 117, 33, 143, 200, 56, 43, 29, 133,
				2, 224, 130, 120, 94, 132, 33, 15, 122, 249, 39, 223, 4, 234, 176, 118,
				70, 113, 215, 254, 164, 2, 20, 51, 170, 24, 136, 31, 109, 114, 161, 84,
				180, 118, 92, 147, 11, 8, 104, 221, 32, 86, 87, 148, 255, 223, 236, 12,
				207, 12, 100, 98, 149, 220, 109, 221, 202, 181, 21, 8, 4, 201, 184, 55,
				67, 103, 251, 155, 54, 222, 27, 3, 153, 218, 27, 241, 179, 31, 4, 150,
				116, 255, 172, 135, 94, 101, 242, 234, 69, 135, 196, 36, 110, 54, 181, 232,
				4, 192, 153, 166, 7, 22, 92, 4, 215, 147, 230, 155, 221, 186, 48, 132,
				246, 9, 245, 11, 56, 196, 157, 244, 196, 180, 10, 239, 171, 152, 112, 142,
				33, 251, 228, 138, 75, 193, 102, 184, 107, 67, 240, 15, 130, 43, 251, 228,
				89, 89, 161, 98, 154, 227, 249, 26, 104, 3, 220, 241, 48, 253, 216, 90,
				196, 216, 145, 111, 18, 127, 92, 226, 55, 220, 136, 92, 83, 72, 85, 167,
				46, 71, 243, 164, 147, 170, 106, 99, 235, 239, 87, 9, 238, 216, 172, 247,
				252, 85, 140, 129, 63, 178, 153, 139, 198, 131, 33, 118, 159, 149, 245, 63,
				71, 211, 20, 32, 233, 155, 11, 88, 121, 120, 70, 2, 46, 145, 225, 147,
				146, 53, 178, 175, 95, 29, 152, 239, 157, 252, 192, 190, 88, 12, 84, 160,
				134, 221, 238, 146, 242, 121, 200, 157, 240, 251, 88, 36, 114, 73, 123, 222,
				192, 18, 157, 21, 181, 33, 166, 32, 15, 145, 224, 44, 231, 224, 244, 97,
				222, 154, 253, 224, 103, 102, 234, 14, 87, 241, 154, 117, 204, 6, 40, 18,
				231, 144, 107, 245, 99, 134, 237, 2, 90, 80, 93, 68, 205, 95, 190, 77,
				188, 11, 134, 212, 168, 90, 176, 166}),
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := new(Rotor).New(proFormaRotors[0].Size, proFormaRotors[0].Start, proFormaRotors[0].Size, append([]byte(nil), proFormaRotors[0].Rotor...))
			r.Update(rnd)
			if !reflect.DeepEqual(r, tt.want) {
				t.Errorf("Updated Rotor() = %v, want %v", r, tt.want)
			}
		})
	}
}

func TestRotor_sliceRotor(t *testing.T) {
	tests := []struct {
		name string
	}{
		{
			name: "trsr1",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := new(Rotor).New(1783, 863, 1033, []byte{
				184, 25, 190, 250, 35, 11, 111, 218, 111, 1, 44, 59, 137, 12, 184, 22,
				154, 226, 101, 88, 167, 109, 45, 92, 19, 164, 132, 233, 34, 133, 138, 222,
				59, 49, 123, 208, 179, 248, 61, 216, 55, 59, 235, 57, 67, 172, 233, 232,
				87, 236, 189, 170, 196, 124, 216, 109, 4, 106, 207, 150, 166, 164, 99, 57,
				131, 27, 1, 236, 168, 78, 122, 81, 165, 26, 32, 56, 129, 105, 35, 26,
				247, 208, 56, 235, 91, 183, 67, 150, 112, 103, 173, 197, 69, 13, 115, 14,
				129, 206, 74, 46, 119, 208, 95, 67, 119, 7, 191, 210, 128, 117, 140, 245,
				41, 168, 63, 203, 53, 241, 221, 28, 158, 40, 89, 76, 126, 58, 33, 40,
				78, 130, 93, 116, 206, 66, 4, 10, 109, 86, 150, 53, 200, 34, 26, 37,
				232, 185, 214, 47, 131, 18, 241, 210, 18, 81, 107, 161, 97, 65, 238, 250,
				81, 133, 54, 158, 54, 10, 254, 135, 110, 162, 175, 250, 117, 66, 232, 66,
				50, 102, 70, 76, 185, 249, 57, 59, 247, 195, 101, 8, 157, 235, 24, 94,
				204, 74, 100, 196, 93, 24, 179, 27, 118, 168, 29, 10, 38, 204, 210, 123,
				111, 247, 225, 171, 60, 166, 239, 124, 43, 180, 223, 240, 66, 2, 68, 220,
				12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
			r.sliceRotor()
			if !reflect.DeepEqual(r, proFormaRotors[0]) {
				t.Errorf("Sliced Rotor() = %v, want %v", r, proFormaRotors[0])
			}
		})
	}
}

func TestRotor_SetIndex(t *testing.T) {
	type args struct {
		idx *big.Int
	}
	tests := []struct {
		name string
		args args
		want int
	}{
		{
			name: "trsi1",
			args: args{
				idx: big.NewInt(10000),
			},
			want: 161,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := proFormaRotors[0]
			r.SetIndex(tt.args.idx)
			if r.Current != tt.want {
				t.Errorf("r.Current = %v, want %v", r.Current, tt.want)
			}
		})
	}
}

func TestRotor_Index(t *testing.T) {
	tests := []struct {
		name string
		want *big.Int
	}{
		{
			name: "trsi1",
			want: nil,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := proFormaRotors[0]
			if got := r.Index(); got != tt.want {
				t.Errorf("Rotor.Index() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestRotor_ApplyF(t *testing.T) {
	type args struct {
		blk CipherBlock
	}
	tests := []struct {
		name string
		args args
		want CipherBlock
	}{
		{
			name: "tpaf1",
			args: args{
				[]byte{
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				},
			},
			want: []byte{
				184, 25, 190, 250, 35, 11, 111, 218, 111, 1, 44, 59, 137, 12, 184, 22,
				154, 226, 101, 88, 167, 109, 45, 92, 19, 164, 132, 233, 34, 133, 138, 222,
			},
		},
		{
			name: "tpaf2",
			args: args{
				[]byte{
					0, 0, 0, 0,
				},
			},
			want: []byte{
				184, 25, 190, 250,
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := proFormaRotors[0]
			r.Current = 0
			if got := r.ApplyF(tt.args.blk); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("Rotor.ApplyF() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestRotor_ApplyG(t *testing.T) {
	type args struct {
		blk CipherBlock
	}
	tests := []struct {
		name string
		args args
		want CipherBlock
	}{
		{
			name: "tpag1",
			args: args{
				[]byte{
					184, 25, 190, 250, 35, 11, 111, 218, 111, 1, 44, 59, 137, 12, 184, 22,
					154, 226, 101, 88, 167, 109, 45, 92, 19, 164, 132, 233, 34, 133, 138, 222,
				},
			},
			want: []byte{
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			},
		},
		{
			name: "tpag2",
			args: args{
				[]byte{
					184, 25, 190, 250,
				},
			},
			want: []byte{
				0, 0, 0, 0,
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := proFormaRotors[0]
			r.Current = 0
			if got := r.ApplyG(tt.args.blk); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("Rotor.ApplyG() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestRotor_String(t *testing.T) {
	tests := []struct {
		name string
		want string
	}{
		{
			name: "trs1",
			want: "new(Rotor).New(1783, 863, 1033, []byte{\n" +
				"\t184, 25, 190, 250, 35, 11, 111, 218, 111, 1, 44, 59, 137, 12, 184, 22, \n" +
				"\t154, 226, 101, 88, 167, 109, 45, 92, 19, 164, 132, 233, 34, 133, 138, 222, \n" +
				"\t59, 49, 123, 208, 179, 248, 61, 216, 55, 59, 235, 57, 67, 172, 233, 232, \n" +
				"\t87, 236, 189, 170, 196, 124, 216, 109, 4, 106, 207, 150, 166, 164, 99, 57, \n" +
				"\t131, 27, 1, 236, 168, 78, 122, 81, 165, 26, 32, 56, 129, 105, 35, 26, \n" +
				"\t247, 208, 56, 235, 91, 183, 67, 150, 112, 103, 173, 197, 69, 13, 115, 14, \n" +
				"\t129, 206, 74, 46, 119, 208, 95, 67, 119, 7, 191, 210, 128, 117, 140, 245, \n" +
				"\t41, 168, 63, 203, 53, 241, 221, 28, 158, 40, 89, 76, 126, 58, 33, 40, \n" +
				"\t78, 130, 93, 116, 206, 66, 4, 10, 109, 86, 150, 53, 200, 34, 26, 37, \n" +
				"\t232, 185, 214, 47, 131, 18, 241, 210, 18, 81, 107, 161, 97, 65, 238, 250, \n" +
				"\t81, 133, 54, 158, 54, 10, 254, 135, 110, 162, 175, 250, 117, 66, 232, 66, \n" +
				"\t50, 102, 70, 76, 185, 249, 57, 59, 247, 195, 101, 8, 157, 235, 24, 94, \n" +
				"\t204, 74, 100, 196, 93, 24, 179, 27, 118, 168, 29, 10, 38, 204, 210, 123, \n" +
				"\t111, 247, 225, 171, 60, 166, 239, 124, 43, 180, 223, 240, 66, 2, 68, 220, \n" +
				"\t12, 95, 253, 145, 133, 55, 237, 183, 0, 150, 157, 68, 6, 92, 11, 77, \n" +
				"\t241, 50, 172, 211, 182, 22, 174, 9, 82, 194, 116, 145, 66, 69, 111, 0})\n",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := proFormaRotors[0]
			if got := r.String(); got != tt.want {
				t.Errorf("Rotor.String() = %v, want = %v", got, tt.want)
			}
		})
	}
}
